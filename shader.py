from pyglet.gl import (    GLuint, GLint, GLfloat, GLException,    glCreateShader, glShaderSource, glCompileShader, glGetShaderiv, glCreateProgram, glAttachShader,    glBindAttribLocation, glLinkProgram, glValidateProgram, glGetUniformLocation, glGetProgramiv,    glGetShaderInfoLog, glGetProgramInfoLog, glUseProgram,    glUniform1f, glUniform2f, glUniform3f, glUniform4f, glUniform1i, glUniform2i, glUniform3i, glUniform4i,    glUniform1ui, glUniform2ui, glUniform3ui, glUniform4ui,    glUniform1fv, glUniform2fv, glUniform3fv, glUniform4fv, glUniform1iv, glUniform2iv, glUniform3iv, glUniform4iv,    glUniform1uiv, glUniform2uiv, glUniform3uiv, glUniform4uiv,    glUniformMatrix2fv, glUniformMatrix3fv, glUniformMatrix4fv,    GL_FALSE, GL_TRUE, GL_COMPILE_STATUS, GL_LINK_STATUS, GL_VALIDATE_STATUS, GL_ATTACHED_SHADERS, GL_ACTIVE_ATTRIBUTES,    GL_ACTIVE_UNIFORMS, GL_VERTEX_SHADER, GL_FRAGMENT_SHADER, GL_INFO_LOG_LENGTH,)from c_bindings import c_string, c_string_array, c_array, byref, create_string_buffer, pointer, cast, POINTERfrom typing import Dictimport sysimport numpy# from pyglet.gl.lib import link_GL, link_WGL # WGLFunctionProxyCHECK_ERROR = TrueCHECK_WARNING = TrueCRASH_ON_ERROR = TrueCRASH_ON_WARNING = False# -------------------------------------- Shader -------------------------------------------------class Shader(GLuint):    """    Shader is a static object. Once created it cannot be changed. Instead you need to delete it and create a new.    """    def __init__(self, shader_type, source=None, path=None):        """        Creates a shader object from either a source string or a text file at path.                Args:            shader_type: GL_VERTEX_SHADER or GL_FRAGMENT_SHADER.            source: String of the code to use for the shader.            path: Path to a text file containing the code for the shader.        """        if path:            source = open(path).read()        handle = -1        try:            handle = create_shader(shader_type)            add_source(handle, source)            compile_shader(handle)        except GLException:            debug_shader(handle)        super(Shader, self).__init__(handle)        self.shader_type = shader_type        self.source = source        self.path = path        if CHECK_ERROR:            debug_shader(self)    def __repr__(self):        shader_name = 'Vertex' if self.shader_type == GL_VERTEX_SHADER else 'Fragment'        return '%s shader (ID=%s, path=%s)' % (shader_name, self.value, self.path)class VertexShader(Shader):    def __init__(self, source=None, path=None):        super(VertexShader, self).__init__(shader_type=GL_VERTEX_SHADER, source=source, path=path)class FragmentShader(Shader):    def __init__(self, source=None, path=None):        super(FragmentShader, self).__init__(shader_type=GL_FRAGMENT_SHADER, source=source, path=path)def create_shader(shader_type: int) -> GLuint:    """    Returns a non-zero value which reference a empty shader.    Errors:        GL_INVALID_ENUM:  if shaderType is not an accepted value.    Args:        shader_type:  GL_VERTEX_SHADER, GL_GEOMETRY_SHADER, GL_FRAGMENT_SHADER    Returns:    """    handle = glCreateShader(shader_type)    return handledef add_source(shader: GLuint, source: str):    """    Sets the source code in shader to the source code in the string 'source'. Any source code previously stored in the     shader object is completely replaced.    Errors:        GL_INVALID_VALUE:      if shader is not a value generated by OpenGL.        GL_INVALID_OPERATION:  if shader is not a shader object.        GL_INVALID_VALUE:      if count is less than 0.    Args:        shader:  The handle to the shader.        source:  A string containing the GLSL source code for the shader.    Returns:        None    """    # shader handle, number of strings, the source, an array of each strings length (null means it's null terminated).    glShaderSource(shader, 1, c_string_array(source, count=1), None)def compile_shader(shader: GLuint):    """    Errors:        GL_INVALID_VALUE:      if shader is not a value generated by OpenGL.        GL_INVALID_OPERATION:  if shader is not a shader object.    Args:        shader:     Returns:    """    glCompileShader(shader)def shader_status(shader: GLuint, status_type: int) -> GLint:    """    Returns the status of the 'shader' for any given 'status_type'.    Errors:        GL_INVALID_VALUE:      if shader is not a value generated by OpenGL.        GL_INVALID_OPERATION:  if shader does not refer to a shader object.        GL_INVALID_ENUM:       if status_type is not an accepted value.    Args:        shader:       The handle to the shader.        status_type:  GL_SHADER_TYPE, GL_DELETE_STATUS, GL_COMPILE_STATUS, GL_INFO_LOG_LENGTH, GL_SHADER_SOURCE_LENGTH.    Returns:    """    status = GLint()    glGetShaderiv(shader, status_type, byref(status))    return status.valuedef debug_shader(shader: Shader):    """        Args:        shader: Handle to the shader.    Returns:    """    error = False    def print_error(message):        nonlocal error        error = True        status = GLint()        glGetShaderiv(shader, GL_INFO_LOG_LENGTH, byref(status))        output = create_string_buffer(status.value)        glGetShaderInfoLog(shader, status, None, output)        print(message, output.value.decode('utf-8'), 'Shader source:', shader.source, file=sys.stderr, sep='\n',              flush=True)    if shader == -1:        print_error('Could not create shader!')    if shader_status(shader, GL_COMPILE_STATUS) == GL_FALSE:        print_error('Could not compile %s!' % shader)    if error and CRASH_ON_ERROR:        sys.exit(-1)# -------------------------------------- PROGRAM -------------------------------------------------class Program(GLuint):    def __init__(self, vertex_shader: Shader, fragment_shader: Shader, attributes=(), uniforms=()):        """        The process of creating a shader can be divided into 6 steps:                    1. Create an ID.            2. Attach shaders.            3. Bind attributes.            4. Link program.            5. Validate program.            6. Bind uniforms.                Args:            vertex_shader:             fragment_shader:             attributes:             uniforms:         """        handle = -1        attribute_table = {}        uniform_table = {}        try:            handle = create_program()            attach_shader(handle, vertex_shader, fragment_shader)            attribute_table = bind_attributes(handle, attributes)            link_program(handle)            validate_program(handle)            uniform_table = bind_uniforms(handle, uniforms)        except GLException:            debug_program(handle)        super(Program, self).__init__(handle)        self.vertex_shader = vertex_shader        self.fragment_shader = fragment_shader        self.attribute_table = attribute_table        self.uniform_table = uniform_table        if CHECK_ERROR:            debug_program(self)            scan(self)    def __repr__(self):        return 'Shader program (ID=%s)' % self.value    def __enter__(self):        glUseProgram(self)    def __exit__(self, exc_type, exc_val, exc_tb):        glUseProgram(0)    def load_uniform_matrix(self, matrix, *ignore, name=None):        """        Args:            matrix: A numpy array.             name:         Returns:        """        if CHECK_ERROR:            if name is None:                raise ValueError('Uniform name must be specified as keyword!')            elif matrix.shape != (4, 4):                raise TypeError('Matrix must be of shape 4x4, not {}x{}!'.format(*matrix.shape))        location = self.uniform_table[name]        data = matrix.ctypes.data_as(POINTER(GLfloat))        glUniformMatrix4fv(location, 1, GL_TRUE, data)    def load_uniform_floats(self, *values, name=None):        if CHECK_ERROR:            if name is None:                raise ValueError('Uniform name must be specified as keyword!')            elif len(values) > 4:                raise ValueError('Can only load up to 4 floats, not %i!' % len(values))        count = len(values) - 1        location = self.uniform_table[name]        (glUniform1f, glUniform2f, glUniform3f, glUniform4f)[count](location, *values)        # This does not work since a vec3 needs glUniform3fv(loc, 1, data) and float glUniform1fv(loc, 1, data)        # array = c_array(values, GLfloat)        # data = cast(pointer(array), POINTER(GLfloat))        # glUniform1fv(location, count, data)    def load_uniform_struct(self, struct, name=None):        for attribute_name in struct.__slots__:            location = self.uniform_table[name + '.' + attribute_name]            attribute = getattr(struct, attribute_name)            if hasattr(attribute, '__len__'):                count = len(attribute) - 1                if count < 4:                    (glUniform1f, glUniform2f, glUniform3f, glUniform4f)[count](location, *attribute)                else:                    self.load_uniform_array(attribute, name=attribute_name)            else:                if attribute.dtype == numpy.uint32:                    glUniform1i(location, attribute)  # Samplers should be set with integers.                else:                    glUniform1f(location, attribute)    def load_uniform_array(self, array, name=None):        row, col = array.shape        if array.dtype == numpy.int32:            func = (glUniform1fv, glUniform2fv, glUniform3fv, glUniform4fv)[row - 1]        elif array.dtype == numpy.uint32:            func = (glUniform1iv, glUniform2iv, glUniform3iv, glUniform4iv)[row - 1]        else:            func = (glUniform1uiv, glUniform2uiv, glUniform3uiv, glUniform4uiv)[row - 1]        # TODO Uniform table should only take the array name and not index. The array name will return the first index        # of the array when calling glGetUniformLocation. Then add functionality so the user can access at any index.        location = self.uniform_table[name + '[0]']        data = cast(pointer(c_array(array, GLfloat)), POINTER(GLfloat))        func(location, 1, data)    def load_uniform_array_of_structs(self, struct, name=None):        for attribute_name in struct.__slots__:            location = self.uniform_table[name + '.' + attribute_name]            attribute = getattr(struct, attribute_name)            if hasattr(attribute, '__len__'):                count = len(attribute) - 1                if count < 4:                    (glUniform1f, glUniform2f, glUniform3f, glUniform4f)[count](location, *attribute)                else:                    self.load_uniform_array(attribute, name=attribute_name)            else:                if attribute.dtype == numpy.uint32:                    glUniform1i(location, attribute)  # Samplers should be set with integers.                else:                    glUniform1f(location, attribute)def create_program() -> GLuint:    """    Returns a non-zero value which reference an empty program.    Returns:    """    handle = glCreateProgram()    return handledef attach_shader(program: GLuint, vertex_shader: GLuint, fragment_shader: GLuint):    """    Errors:        GL_INVALID_VALUE:      if either program or shader is not a value generated by OpenGL.        GL_INVALID_OPERATION:  if program is not a program object.        GL_INVALID_OPERATION:  if shader is not a shader object.        GL_INVALID_OPERATION:  if shader is already attached to program.    Args:        program:         The handle to the program.        vertex_shader:   The handle to the shader.        fragment_shader: The handle to the shader.    Returns:    """    glAttachShader(program, vertex_shader)    glAttachShader(program, fragment_shader)def bind_attributes(program: GLuint, attributes: list) -> Dict[str, int]:    """    Errors:        GL_INVALID_VALUE:       if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.        GL_INVALID_VALUE:       if program is not a value generated by OpenGL.        GL_INVALID_OPERATION:   if name starts with the reserved prefix "gl_".        GL_INVALID_OPERATION:   if program is not a program object.    Args:        program:     The handle to the program.        attributes:     Returns:    """    attribute_table = {}    for index, name in enumerate(attributes):        glBindAttribLocation(program, index, c_string(name))        attribute_table[name] = index    return attribute_tabledef link_program(program: GLuint):    """    Errors:        GL_INVALID_VALUE:      if program is not a value generated by OpenGL.        GL_INVALID_OPERATION:  if program is not a program object.        GL_INVALID_OPERATION:  if program is the currently active program object and transform feedback mode is active.    Args:        program: The handle to the program.    Returns:    """    glLinkProgram(program)def validate_program(program: GLuint):    """    Errors        GL_INVALID_VALUE:      if program is not a value generated by OpenGL.        GL_INVALID_OPERATION:  if program is not a program object.    Args:        program: The handle to the program.    Returns:    """    glValidateProgram(program)def bind_uniforms(program: GLuint, uniforms: list) -> Dict[str, int]:    """    Errors:        GL_INVALID_VALUE:      if program is not a value generated by OpenGL.        GL_INVALID_OPERATION:  if program is not a program object.        GL_INVALID_OPERATION:  if program has not been successfully linked.    Args:        program:  The handle to the program.        uniforms:     Returns:    """    uniform_table = {}    for name in uniforms:        uniform_table[name] = glGetUniformLocation(program, c_string(name))    return uniform_tabledef program_status(program: GLuint, status_type: int) -> int:    """    Args:        program:      The handle to the program.        status_type:  GL_DELETE_STATUS, GL_LINK_STATUS, GL_VALIDATE_STATUS, GL_INFO_LOG_LENGTH, GL_ATTACHED_SHADERS,                       GL_ACTIVE_ATOMIC_COUNTER_BUFFERS, GL_ACTIVE_ATTRIBUTES, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH,                       GL_ACTIVE_UNIFORMS, GL_ACTIVE_UNIFORM_BLOCKS, GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH,                       GL_ACTIVE_UNIFORM_MAX_LENGTH, GL_COMPUTE_WORK_GROUP_SIZE GL_PROGRAM_BINARY_LENGTH,                       GL_TRANSFORM_FEEDBACK_BUFFER_MODE, GL_TRANSFORM_FEEDBACK_VARYINGS,                       GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH, GL_GEOMETRY_VERTICES_OUT, GL_GEOMETRY_INPUT_TYPE,                       GL_GEOMETRY_OUTPUT_TYPE.    Returns:        Status code.    """    status = GLint()    glGetProgramiv(program, status_type, byref(status))    return status.valuedef debug_program(program: Program):    """        Args:        program: The handle to the program.    Returns:    """    error = False    def print_error(message):        nonlocal error        error = True        status = GLint()        glGetProgramiv(program, GL_INFO_LOG_LENGTH, byref(status))  # Getting the number of char in info log to 'status'        output = create_string_buffer(status.value)  # status.value)        glGetProgramInfoLog(program, status, None, output)        print(message, output.value.decode('utf-8'), file=sys.stderr)    if program == -1:        print_error('Could not create program!')    if program_status(program, GL_LINK_STATUS) == GL_FALSE:        print_error('Could not link program!')    if program_status(program, GL_VALIDATE_STATUS) == GL_FALSE:        print_error('Validation failed!')    if program_status(program, GL_ATTACHED_SHADERS) != 2:        print_error('Wrong amount of shaders attached!')    # # TODO These are more of warnings than errors.    # if program_status(program, GL_ACTIVE_ATTRIBUTES) < len(program.attribute_table):    #     # TODO There are non user defined attributes and uniforms. Also fails for structs!    #     print_error('Unused attributes attributes in shader program!')    # if program_status(program, GL_ACTIVE_UNIFORMS) < len(program.uniform_table):    #     print_error('Unused uniforms attributes in shader program!')    if error and CRASH_ON_ERROR:        sys.exit(-1)def scan(program: Program):    """    We scan through the vertex shader and the fragment shader to see if the attributes and uniforms uploaded to the     program match those in the shaders.        All attributes starts with the keyword `attribute` at the lowest indention level. Some attributes are not loaded to    the program, which are the ones that start with the `gl_` prefix.        Uniforms starts with the keyword `uniform` at the lowest indention level. Uniforms are more flexible than attributes    since they can be basic data types, structs, array or array of structs. There are also predefined uniforms     `sampler1D`, `sampler2D` och `sampler3D`.            Built-in data types are:        bool, int, uint, float, double        bvec, ivec, uvec, vec, dvec        mat        sampler        Args:        program:     Returns:        None    """    # TODO Tidy up function.    # TODO Maybe separate into warnings and errors?    data_types = [        'bool', 'int', 'uint', 'float', 'double', 'bvec2', 'ivec2', 'uvec2', 'vec2', 'dvec2', 'bvec3', 'ivec3', 'uvec3',        'vec3', 'dvec3', 'bvec4', 'ivec4', 'uvec4', 'vec4', 'dvec4', 'mat4', 'sampler1D', 'sampler2D', 'sampler3D']    struct_members = {}    attributes = set()    uniforms = set()    source = program.vertex_shader.source.split()    index = 0    while index < len(source):        if source[index] == 'struct':            index += 1            struct_name = source[index].replace('{', '')            struct_members[struct_name] = []            while not '};' in source[index]:                if source[index] in data_types:                    index += 1                    if '[' in source[index]:                        temp = []                        for character in source[index]:                            if character == '[':                                break                            else:                                temp.append(character)                        member = ''.join(temp)                    else:                        member = source[index].replace(';', '')                    struct_members[struct_name].append(member)                index += 1        elif source[index] == 'attribute':            index += 2            attributes.add(source[index].replace(';', ''))        elif source[index] == 'uniform':            index += 1            if source[index] in struct_members:                struct = source[index]                index += 1                if '[' in source[index]:                    temp = []                    for character in source[index]:                        if character == '[':                            break                        else:                            temp.append(character)                    name = ''.join(temp)                else:                    name = source[index].replace(';', '')                for member in struct_members[struct]:                    uniforms.add(name + '.' + member)        index += 1    source = program.fragment_shader.source.split()    index = 0    while index < len(source):        if source[index] == 'struct':            index += 1            struct_name = source[index].replace('{', '')            struct_members[struct_name] = []            while not '};' in source[index]:                if source[index] in data_types:                    index += 1                    if '[' in source[index]:                        temp = []                        for character in source[index]:                            if character == '[':                                break                            else:                                temp.append(character)                        member = ''.join(temp)                    else:                        member = source[index].replace(';', '')                    struct_members[struct_name].append(member)                index += 1        elif source[index] == 'uniform':            index += 1            if source[index] in struct_members:                struct = source[index]                index += 1                if '[' in source[index]:                    temp = []                    for character in source[index]:                        if character == '[':                            break                        else:                            temp.append(character)                    name = ''.join(temp)                else:                    name = source[index].replace(';', '')                for member in struct_members[struct]:                    uniforms.add(name + '.' + member)        index += 1    template = """{name} uploaded to the program do not match those used the shaders.    {name} in the program: {program_attributes}    {name} in the shaders: {attributes}"""    error = False    if set(attributes) != set(program.attribute_table):        print(            template.format(                name='Attributes',                program_attributes=', '.join(sorted(program.attribute_table.keys())),                attributes=', '.join(sorted(attributes))            ),            file=sys.stderr        )        error = True    if set(uniforms) != set(program.uniform_table):        print(            template.format(                name='Uniforms',                program_attributes=', '.join(sorted(program.uniform_table)),                attributes=', '.join(sorted(uniforms))            ),            file=sys.stderr        )        error = True    if error and CRASH_ON_ERROR:        sys.exit(-1)# def scan_try(vertex_source, fragment_source):#     data_types = [#         'bool', 'int', 'uint', 'float', 'double', 'bvec2', 'ivec2', 'uvec2', 'vec2', 'dvec2', 'bvec3', 'ivec3', 'uvec3',#         'vec3', 'dvec3', 'bvec4', 'ivec4', 'uvec4', 'vec4', 'dvec4', 'mat4', 'sampler1D', 'sampler2D', 'sampler3D']##     struct_members = {}#     attributes = set()#     uniforms = set()##     source = vertex_source.split()#     index = 0#     while index < len(source):#         if source[index] == 'struct':#             index += 1#             struct_name = source[index].replace('{', '')#             struct_members[struct_name] = []#             while not '};' in source[index]:#                 if source[index] in data_types:#                     index += 1#                     if '[' in source[index]:#                         temp = []#                         for character in source[index]:#                             if character == '[':#                                 break#                             else:#                                 temp.append(character)#                         member = ''.join(temp)#                     else:#                         member = source[index].replace(';', '')#                     struct_members[struct_name].append(member)#                 index += 1#         elif source[index] == 'attribute':#             index += 2#             attributes.add(source[index].replace(';', ''))#         elif source[index] == 'uniform':#             index += 1#             if source[index] in struct_members:#                 struct = source[index]#                 index += 1#                 if '[' in source[index]:#                     temp = []#                     for character in source[index]:#                         if character == '[':#                             break#                         else:#                             temp.append(character)#                     name = ''.join(temp)#                 else:#                     name = source[index].replace(';', '')#                 for member in struct_members[struct]:#                     uniforms.add(name + '.' + member)#         index += 1##     source = fragment_source.split()#     index = 0#     while index < len(source):#         if source[index] == 'struct':#             index += 1#             struct_name = source[index].replace('{', '')#             struct_members[struct_name] = []#             while not '};' in source[index]:#                 if source[index] in data_types:#                     index += 1#                     if '[' in source[index]:#                         temp = []#                         for character in source[index]:#                             if character == '[':#                                 break#                             else:#                                 temp.append(character)#                         member = ''.join(temp)#                     else:#                         member = source[index].replace(';', '')#                     struct_members[struct_name].append(member)#                 index += 1#         elif source[index] == 'uniform':#             index += 1#             if source[index] in struct_members:#                 struct = source[index]#                 index += 1#                 if '[' in source[index]:#                     temp = []#                     for character in source[index]:#                         if character == '[':#                             break#                         else:#                             temp.append(character)#                     name = ''.join(temp)#                 else:#                     name = source[index].replace(';', '')#                 for member in struct_members[struct]:#                     uniforms.add(name + '.' + member)#         index += 1##     print(attributes, uniforms, struct_members, sep='\n')### scan_try(#     vertex_source=open('shaders/lightning_shader.vs').read(),#     fragment_source=open('shaders/debug_lightning_shader_multiple_lights.fs').read()# )